layout(scene = list(
xaxis = list(title="Columns"),
yaxis = list(title="Partitions"),
zaxis = list(title="CPU time")
))
grid
newdata <- data.frame(
n_leaves = seq(min(df$n_leaves), max(df$n_leaves), length=100),
n_columns = median(df$n_columns),
n_partitions = median(df$n_partitions)
)
newdata$pred <- predict(model4, newdata=newdata)
newdata$CPU_time <- 2^newdata$pred
ggplot(newdata, aes(x = n_leaves, y = CPU_time)) +
geom_line() +
scale_x_log10() + scale_y_log10() +
labs(x="Number of leaves", y="CPU time") +
theme_minimal()
grid <- expand.grid(
n_leaves = median(df$n_leaves),
n_columns = seq(min(df$n_columns), max(df$n_columns), length=50),
n_partitions = seq(min(df$n_partitions), max(df$n_partitions), length=50)
)
# Predict CPU time
grid$pred <- predict(model4, newdata=grid)
grid$pred_time <- 2^grid$pred  # back to CPU time
# Contour plot
ggplot(grid, aes(x = n_columns, y = n_partitions, z = pred_time)) +
geom_contour_filled() +
scale_x_log10() + scale_y_log10() +
labs(x="Number of columns", y="Number of partitions", fill="CPU time") +
theme_minimal()
library(plotly)
plot_ly(grid, x = ~n_columns, y = ~n_partitions, z = ~pred_time, type="surface") %>%
layout(scene = list(
xaxis = list(title="Columns"),
yaxis = list(title="Partitions"),
zaxis = list(title="CPU time")
))
grid <- expand.grid(
n_leaves = median(df$n_leaves),                # hold leaves constant
n_columns = seq(min(df$n_columns), max(df$n_columns), length.out = 100),
n_partitions = seq(min(df$n_partitions), max(df$n_partitions), length.out = 100)
)
grid$pred <- predict(model4, newdata = grid)
grid$CPU_time <- 2^grid$pred
z_matrix <- matrix(grid$CPU_time, nrow=100, ncol=100)
library(plotly)
plot_ly(
x = seq(min(df$n_columns), max(df$n_columns), length.out=100),
y = seq(min(df$n_partitions), max(df$n_partitions), length.out=100),
z = z_matrix,
type = "surface"
) %>%
layout(
scene = list(
xaxis = list(title="Number of columns", type="log"),
yaxis = list(title="Number of partitions", type="log"),
zaxis = list(title="CPU time")
)
)
# Runtime ~ leaves + characters + partitions + leaves:characters
model4 <- lm(log2(swap_CPU_time) ~ log2(n_leaves) + log2(n_columns) + log2(n_partitions) + log2(n_columns):log2(n_partitions), data = df)
summary(model4)
summary(model4)
grid <- expand.grid(
n_leaves = median(df$n_leaves),
n_columns = seq(min(df$n_columns), max(df$n_columns), length=50),
n_partitions = seq(min(df$n_partitions), max(df$n_partitions), length=50)
)
# Predict CPU time
grid$pred <- predict(model4, newdata=grid)
grid$pred_time <- 2^grid$pred  # back to CPU time
# Contour plot
ggplot(grid, aes(x = n_columns, y = n_partitions, z = pred_time)) +
geom_contour_filled() +
scale_x_log10() + scale_y_log10() +
labs(x="Number of columns", y="Number of partitions", fill="CPU time") +
theme_minimal()
# VISUALIZATION
# Plot: time vs Partitions, grouped by (n_leaves, n_columns)
df$group <- interaction(df$n_leaves, df$n_columns, drop = TRUE)
p <- ggplot(df, aes(x = n_partitions, y = swap_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. partitions",
y = "CPU time (s) for phylog2enetic analyses",
color = "No. leaves × No. characters") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
p
ggplot(grid, aes(x = n_columns, y = n_partitions, z = pred_time)) +
geom_contour_filled() +
scale_x_log10() + scale_y_log10() +
labs(x="Number of columns", y="Number of partitions", fill="CPU time") +
theme_minimal()
# Contour plot
ggplot(grid, aes(x = n_columns, y = n_partitions, z = pred_time)) +
geom_contour_filled() +
scale_x_log2() + scale_y_log2() +
labs(x="Number of columns", y="Number of partitions", fill="CPU time") +
theme_minimal()
df$group <- interaction(df$n_leaves, df$n_columns, drop = TRUE)
p <- ggplot(df, aes(x = n_partitions, y = prepDyn_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. partitions",
y = "CPU time (s) for preprocessing",
color = "No. leaves × No. nucleotides") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
p
ggsave("simulations_noPartitionsXtimePreprocessing.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
df$group <- interaction(df$n_columns, df$n_partitions, drop = TRUE)
p <- ggplot(df, aes(x = n_leaves, y = prepDyn_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. leaves",
y = "CPU time (s) for preprocessing",
color = "No. nucleotides × No. partitions") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
p
ggsave("simulations_noLeavesXtimePreprocessing.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
df$group <- interaction(df$n_leaves, df$n_partitions, drop = TRUE)
p <- ggplot(df, aes(x = n_columns, y = prepDyn_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. nucleotides",
y = "CPU time (s) for preprocessing",
color = "No. leaves × No. partitions") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
p
ggsave("simulations_noCharactersXtimePreprocessing.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
p <- ggplot(df, aes(x = n_partitions, y = prepDyn_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. partitions",
y = "CPU time (s) for preprocessing",
color = "No. leaves × No. nucleotides") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
p
ggsave("simulations_noPartitionsXtimePreprocessing.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
df$group <- interaction(df$n_leaves, df$n_columns, drop = TRUE)
p <- ggplot(df, aes(x = n_partitions, y = prepDyn_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. partitions",
y = "CPU time (s) for preprocessing",
color = "No. leaves × No. nucleotides") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
p
ggsave("simulations_noPartitionsXtimePreprocessing.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
df$group <- interaction(df$n_leaves, df$n_columns, drop = TRUE)
p <- ggplot(df, aes(x = n_partitions, y = cost, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. partitions",
y = "Parsimony score",
color = "No. leaves × No. nucleotides") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
p
ggsave("simulations_noPartitionsXcostDO.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
p <- ggplot(df, aes(x = n_partitions, y = cost, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. partitions",
y = "Parsimony score\n",
color = "No. leaves × No. nucleotides") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
p
ggsave("simulations_noPartitionsXcostDO.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
df$group <- interaction(df$n_leaves, df$n_columns, drop = TRUE)
p <- ggplot(df, aes(x = n_partitions, y = cost, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "\nNo. partitions",
y = "Parsimony score\n",
color = "No. leaves × No. nucleotides") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
p
ggsave("simulations_noPartitionsXcostDO.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
# VISUALIZATION
# Plot: time vs Partitions, grouped by (n_leaves, n_columns)
df$group <- interaction(df$n_leaves, df$n_columns, drop = TRUE)
p <- ggplot(df, aes(x = n_partitions, y = swap_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "\nNo. partitions",
y = "CPU time (s) for direct optimization",
color = "No. leaves × No. nucleotides") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
p
p <- ggplot(df, aes(x = n_partitions, y = swap_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "\nNo. partitions",
y = "CPU time (s) for direct optimization\n",
color = "No. leaves × No. nucleotides") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
p
p
ggsave("simulations_noPartitionsXtimeDO.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
# 2D plot
grid <- expand.grid(
n_leaves = median(df$n_leaves),
n_columns = seq(min(df$n_columns), max(df$n_columns), length=50),
n_partitions = seq(min(df$n_partitions), max(df$n_partitions), length=50)
)
# Predict CPU time
grid$pred <- predict(model4, newdata=grid)
grid$pred_time <- 2^grid$pred  # back to CPU time
# Contour plot
p=ggplot(grid, aes(x = n_columns, y = n_partitions, z = pred_time)) +
geom_contour_filled() +
scale_x_log10() + scale_y_log10() +
labs(x="Number of nucleotides", y="Number of partitions", fill="CPU time") +
theme_minimal()
p
# Contour plot
p=ggplot(grid, aes(x = n_columns, y = n_partitions, z = pred_time)) +
geom_contour_filled() +
scale_x_log10() + scale_y_log10() +
labs(x="\nNo nucleotides", y="No. partitions\n", fill="CPU time") +
theme_minimal()
p
# Contour plot
p=ggplot(grid, aes(x = n_columns, y = n_partitions, z = pred_time)) +
geom_contour_filled() +
scale_x_log10() + scale_y_log10() +
labs(x="\nNo. nucleotides", y="No. partitions\n", fill="CPU time") +
theme_minimal()
p
p
ggsave("simulations_interactionPartitionsNucleotidesXtimeDO.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
# 3D plot
grid <- expand.grid(
n_leaves = median(df$n_leaves),                # hold leaves constant
n_columns = seq(min(df$n_columns), max(df$n_columns), length.out = 100),
n_partitions = seq(min(df$n_partitions), max(df$n_partitions), length.out = 100)
)
grid$pred <- predict(model4, newdata = grid)
grid$CPU_time <- 2^grid$pred
z_matrix <- matrix(grid$CPU_time, nrow=100, ncol=100)
library(plotly)
plot_ly(
x = seq(min(df$n_columns), max(df$n_columns), length.out=100),
y = seq(min(df$n_partitions), max(df$n_partitions), length.out=100),
z = z_matrix,
type = "surface"
) %>%
layout(
scene = list(
xaxis = list(title="Number of columns", type="log"),
yaxis = list(title="Number of partitions", type="log"),
zaxis = list(title="CPU time")
)
)
p
model4
model4
summary(model4)
predict(model4)
summary(model1)
# LINEAR MODELS
# Runtime ~ leaves * characters * partitions
model1 <- lm(log2(swap_CPU_time) ~ log2(n_leaves) * log2(n_columns) * log2(n_partitions), data = df)
summary(model1)
# Runtime ~ leaves + characters + partitions + leaves:partitions + characters:partitions
model2 <- lm(log2(swap_CPU_time) ~ log2(n_leaves) + log2(n_columns) + log2(n_partitions) + log2(n_leaves):log2(n_partitions) + log2(n_columns):log2(n_partitions), data = df)
summary(model2)
# Runtime ~ leaves + characters + partitions + leaves:partitions
model3 <- lm(log2(swap_CPU_time) ~ log2(n_leaves) + log2(n_columns) + log2(n_partitions) + log2(n_leaves):log2(n_partitions), data = df)
summary(model3)
# Runtime ~ leaves + characters + partitions + leaves:characters
model4 <- lm(log2(swap_CPU_time) ~ log2(n_leaves) + log2(n_columns) + log2(n_partitions) + log2(n_columns):log2(n_partitions), data = df)
summary(model4)
# Runtime ~ leaves + characters + partitions
model5 <- lm(log2(swap_CPU_time) ~ log2(n_leaves) + log2(n_columns) + log2(n_partitions), data = df)
summary(model5)
df
df_subset <- subset(df, n_leaves == 40 & n_columns == 10000)
df_subset <- subset(df, n_leaves == 40 & n_columns == 10000)
# LINEAR MODELS
# Runtime ~ leaves * characters * partitions
model1 <- lm(log2(swap_CPU_time) ~ log2(n_leaves) * log2(n_columns) * log2(n_partitions), data = df_subset)
summary(model1)
df_subset
# LINEAR MODELS
model <- lm(log2(swap_CPU_time) ~ log2(n_partitions), data = df_subset)
summary(model)
df_subset$n_partitions
(df_subset$n_partitions)
length(df_subset$n_partitions)
# LINEAR MODEL
model_lm <- lm(log2(swap_CPU_time) ~ log2(n_partitions), data = df_subset)
summary(model_lm)
# NONLINEAR MODEL
model_gam = gam(log2(swap_CPU_time) ~ s(log2(n_partitions),k=8),
data=df_subset)
summary(model_gam)
AIC(model_lm, model_gam)
library(mgcv)
# Base plot
plot(model_gam, shade=TRUE, main="Effect of n_partitions on CPU time")
# Or ggplot with predicted values
newdata <- data.frame(n_partitions = seq(min(df_subset$n_partitions),
max(df_subset$n_partitions),
length.out=100))
newdata$pred <- predict(model_gam, newdata=newdata, type="response")
newdata$CPU_time <- 2^newdata$pred  # back to original scale
ggplot(newdata, aes(x=n_partitions, y=CPU_time)) +
geom_line() +
scale_y_log10() +
labs(x="Number of partitions", y="CPU time") +
theme_minimal()
# LINEAR MODEL
model_lm <- lm((swap_CPU_time) ~ (n_partitions), data = df_subset)
summary(model_lm)
# NONLINEAR MODEL
model_gam = gam((swap_CPU_time) ~ s((n_partitions),k=8),
data=df_subset)
summary(model_gam)
#Polynomial
model_poly <- lm(log2(swap_CPU_time) ~ poly(log2(n_partitions), 2), data = df_subset)
summary(model_poly)
AIC(model_lm, model_gam, model_poly)
model_lm <- lm(log2(swap_CPU_time) ~ log2(n_partitions), data = df_subset)
summary(model_lm)
# NONLINEAR MODEL
#Gam
model_gam = gam(log2(swap_CPU_time) ~ s(log2(n_partitions),k=8),
data=df_subset)
summary(model_gam)
#Polynomial
model_poly <- lm(log2(swap_CPU_time) ~ poly(log2(n_partitions), 2), data = df_subset)
summary(model_poly)
AIC(model_lm, model_gam, model_poly)
#Polynomial
model_poly <- lm((swap_CPU_time) ~ poly((n_partitions), 2), data = df_subset)
summary(model_poly)
#Polynomial
model_poly <- lm(log2(swap_CPU_time) ~ poly(log2(n_partitions), 2), data = df_subset)
summary(model_poly)
# PLOT POLYNOMIAL
# Create a sequence of partition values
newdata <- data.frame(n_partitions = seq(min(df_subset$n_partitions),
max(df_subset$n_partitions),
length.out=100))
# Predict log2(CPU_time)
newdata$pred <- predict(model_poly3, newdata=newdata)
newdata$CPU_time <- 2^newdata$pred  # back to original scale
# Plot
library(ggplot2)
# PLOT POLYNOMIAL
# Create a sequence of partition values
newdata <- data.frame(n_partitions = seq(min(df_subset$n_partitions),
max(df_subset$n_partitions),
length.out=100))
# Predict log2(CPU_time)
newdata$pred <- predict(model_poly3, newdata=newdata)
# Predict log2(CPU_time)
newdata$pred <- predict(model_poly, newdata=newdata)
newdata$CPU_time <- 2^newdata$pred  # back to original scale
# Plot
library(ggplot2)
ggplot(newdata, aes(x=n_partitions, y=CPU_time)) +
geom_line(color="blue", size=1) +
geom_point(data=df_subset, aes(x=n_partitions, y=swap_CPU_time), alpha=0.5) +
scale_y_log10() +
labs(x="Number of partitions", y="CPU time",
title="Polynomial regression of CPU time vs partitions") +
theme_minimal()
ggplot(newdata, aes(x=n_partitions, y=CPU_time)) +
geom_line(color="blue", size=1) +
geom_point(data=df_subset, aes(x=n_partitions, y=swap_CPU_time), alpha=0.5) +
labs(x="Number of partitions", y="CPU time",
title="Polynomial regression of CPU time vs partitions") +
theme_minimal()
# Base plot
plot(model_gam, shade=TRUE, main="Effect of n_partitions on CPU time")
# Or ggplot with predicted values
newdata <- data.frame(n_partitions = seq(min(df_subset$n_partitions),
max(df_subset$n_partitions),
length.out=100))
newdata$pred <- predict(model_gam, newdata=newdata, type="response")
newdata$CPU_time <- 2^newdata$pred  # back to original scale
ggplot(newdata, aes(x=n_partitions, y=CPU_time)) +
geom_line() +
labs(x="Number of partitions", y="CPU time") +
theme_minimal()
#Polynomial
model_poly <- lm(log2(swap_CPU_time) ~ poly(log2(n_partitions), 2), data = df_subset)
summary(model_poly)
#Polynomial
model_poly1 <- lm(log2(swap_CPU_time) ~ poly(log2(n_partitions), 1), data = df_subset)
model_poly2 <- lm(log2(swap_CPU_time) ~ poly(log2(n_partitions), 2), data = df_subset)
model_poly3 <- lm(log2(swap_CPU_time) ~ poly(log2(n_partitions), 3), data = df_subset)
AIC(model_poly1, model_poly2, model_poly3)
summary(model_poly3)
# AIC
AIC(model_lm, model_gam, model_poly3)
# PLOT POLYNOMIAL
# Create a sequence of partition values
newdata <- data.frame(n_partitions = seq(min(df_subset$n_partitions),
max(df_subset$n_partitions),
length.out=100))
# Predict log2(CPU_time)
newdata$pred <- predict(model_poly3, newdata=newdata)
newdata$CPU_time <- 2^newdata$pred  # back to original scale
# Plot
library(ggplot2)
ggplot(newdata, aes(x=n_partitions, y=CPU_time)) +
geom_line(color="blue", size=1) +
geom_point(data=df_subset, aes(x=n_partitions, y=swap_CPU_time), alpha=0.5) +
labs(x="Number of partitions", y="CPU time",
title="Polynomial regression of CPU time vs partitions") +
theme_minimal()
# PLOT POLYNOMIAL
# Create a sequence of partition values
newdata <- data.frame(n_partitions = seq(min(df_subset$n_partitions),
max(df_subset$n_partitions),
length.out=100))
# Predict log2(CPU_time)
newdata$pred <- predict(model_poly2, newdata=newdata)
newdata$CPU_time <- 2^newdata$pred  # back to original scale
# Plot
library(ggplot2)
ggplot(newdata, aes(x=n_partitions, y=CPU_time)) +
geom_line(color="blue", size=1) +
geom_point(data=df_subset, aes(x=n_partitions, y=swap_CPU_time), alpha=0.5) +
labs(x="Number of partitions", y="CPU time",
title="Polynomial regression of CPU time vs partitions") +
theme_minimal()
# PLOT POLYNOMIAL
# Create a sequence of partition values
newdata <- data.frame(n_partitions = seq(min(df_subset$n_partitions),
max(df_subset$n_partitions),
length.out=100))
# Predict log2(CPU_time)
newdata$pred <- predict(model_poly1, newdata=newdata)
newdata$CPU_time <- 2^newdata$pred  # back to original scale
# Plot
library(ggplot2)
ggplot(newdata, aes(x=n_partitions, y=CPU_time)) +
geom_line(color="blue", size=1) +
geom_point(data=df_subset, aes(x=n_partitions, y=swap_CPU_time), alpha=0.5) +
labs(x="Number of partitions", y="CPU time",
title="Polynomial regression of CPU time vs partitions") +
theme_minimal()
#Polynomial
model_poly1 <- lm(log2(swap_CPU_time) ~ poly(log2(n_partitions), 1), data = df_subset)
model_poly2 <- lm(log2(swap_CPU_time) ~ poly(log2(n_partitions), 2), data = df_subset)
model_poly3 <- lm(log2(swap_CPU_time) ~ poly(log2(n_partitions), 3), data = df_subset)
summary(model_poly3)
summary(model_poly2)
summary(model_poly1)
summary(model_poly3)
model_poly4 <- lm(log2(swap_CPU_time) ~ poly(log2(n_partitions), 4), data = df_subset)
AIC(model_poly1, model_poly2, model_poly3, model_poly4)
# PLOT POLYNOMIAL
# Create a sequence of partition values
newdata <- data.frame(n_partitions = seq(min(df_subset$n_partitions),
max(df_subset$n_partitions),
length.out=100))
# Predict log2(CPU_time)
newdata$pred <- predict(model_poly4, newdata=newdata)
newdata$CPU_time <- 2^newdata$pred  # back to original scale
# Plot
library(ggplot2)
ggplot(newdata, aes(x=n_partitions, y=CPU_time)) +
geom_line(color="blue", size=1) +
geom_point(data=df_subset, aes(x=n_partitions, y=swap_CPU_time), alpha=0.5) +
labs(x="Number of partitions", y="CPU time",
title="Polynomial regression of CPU time vs partitions") +
theme_minimal()
summary(model_poly4)
# AIC
AIC(model_lm, model_gam, model_poly4)
# PLOT GAM
library(mgcv)
# Base plot
plot(model_gam, shade=TRUE, main="Effect of n_partitions on CPU time")
# Or ggplot with predicted values
newdata <- data.frame(n_partitions = seq(min(df_subset$n_partitions),
max(df_subset$n_partitions),
length.out=100))
newdata$pred <- predict(model_gam, newdata=newdata, type="response")
newdata$CPU_time <- 2^newdata$pred  # back to original scale
ggplot(newdata, aes(x=n_partitions, y=CPU_time)) +
geom_line() +
labs(x="Number of partitions", y="CPU time") +
theme_minimal()
