if (length(match_idx) > 0) {
edge2 <- which(trees2[[j]]$edge[, 2] == (length(tips1) + match_idx))
lengths <- c(lengths, trees2[[j]]$edge.length[edge2])
}
}
# Assign branch length or 0 if no match (collapsed edge)
if (length(lengths) == 0) {
mapped_lengths[edge_idx] <- 0
} else if (method == "random") {
mapped_lengths[edge_idx] <- sample(lengths, 1)
} else if (method == "minimum") {
mapped_lengths[edge_idx] <- min(lengths)
}
}
# Attach lengths
tree1$edge.length <- mapped_lengths
return(tree1)
}
library(ape)
# Example trees
set.seed(1)
tree1 <- rtree(5)
tree1$edge.length <- NULL  # remove branch lengths (like strict consensus)
trees2 <- list(rtree(5), rtree(5))
# Map using minimum branch length per shared edge
mapped_min <- map_branch_lengths(tree1, trees2, method = "minimum")
# Map using random tree
mapped_rand <- map_branch_lengths(tree1, trees2, method = "random")
plot(mapped_min)
title("Tree1 with mapped minimum branch lengths")
plot(mapped_min)
# Example trees
# Generate two random trees with the same set of taxa
set.seed(123)
trees2 <- list(rtree(5), rtree(5))
# Compute the strict consensus tree
strict_consensus <- consensus(list(trees2[[1]], trees2[[2]]), p = 1.0)
par(mfrow = c(1, 3))
plot(tree1, main = "Tree 1")
plot(tree2, main = "Tree 2")
set.seed(123)
trees2 <- list(rtree(5), rtree(5))
# Compute the strict consensus tree
tree1 <- consensus(list(trees2[[1]], trees2[[2]]), p = 1.0)
# Plot to visualize
par(mfrow = c(1, 3))
plot(trees2[[1]], main = "Tree 1")
plot(trees2[[2]], main = "Tree 2")
plot(tree1, main = "Strict Consensus")
set.seed(44)
trees2 <- list(rtree(10), rtree(10))
# Compute the strict consensus tree
tree1 <- consensus(list(trees2[[1]], trees2[[2]]), p = 1.0)
# Plot to visualize
par(mfrow = c(1, 3))
plot(trees2[[1]], main = "Tree 1")
plot(trees2[[2]], main = "Tree 2")
plot(tree1, main = "Strict Consensus")
set.seed(1)
trees2 <- list(rtree(10), rtree(10))
# Compute the strict consensus tree
tree1 <- consensus(list(trees2[[1]], trees2[[2]]), p = 1.0)
# Plot to visualize
par(mfrow = c(1, 3))
plot(trees2[[1]], main = "Tree 1")
plot(trees2[[2]], main = "Tree 2")
plot(tree1, main = "Strict Consensus")
set.seed(1)
trees2 <- list(rtree(55), rtree(55))
# Compute the strict consensus tree
tree1 <- consensus(list(trees2[[1]], trees2[[2]]), p = 1.0)
# Plot to visualize
par(mfrow = c(1, 3))
plot(trees2[[1]], main = "Tree 1")
plot(trees2[[2]], main = "Tree 2")
plot(tree1, main = "Strict Consensus")
/rtree
?rtree
# Example trees
# Generate two random trees with the same set of taxa
set.seed(1)
trees2 <- rtree(55, N=2)
trees2 <- rtree(n=55, N=2)
set.seed(1)
tree1 <- rtree(n=8)
tree2 = tree1
tree2 <- rNNI(tree2, n = 1)  # perform one NNI (one rearrangement)
# Compute the strict consensus tree
strict <- consensus(list(trees2[[1]], trees2[[2]]), p = 1.0)
# Plot to visualize
par(mfrow = c(1, 3))
plot(tree1, main = "Tree 1")
plot(tree2, main = "Tree 2")
plot(strict, main = "Strict Consensus")
set.seed(1)
tree1 <- rtree(n=8)
tree2 = tree1
tree2 <- rNNI(tree2, n = 1)  # perform one NNI (one rearrangement)
# Compute the strict consensus tree
strict <- consensus(list(tree1, tree2), p = 1.0)
# Plot to visualize
par(mfrow = c(1, 3))
plot(tree1, main = "Tree 1")
plot(tree2, main = "Tree 2")
plot(strict, main = "Strict Consensus")
?consensus
# Compute the strict consensus tree
strict <- phangorn::consensus(list(tree1, tree2), p = 1.0)
?phangorn::consensusNet()
par(mfrow = c(1, 3))
plot(tree1, main = "Tree 1")
plot(tree2, main = "Tree 2")
plot(strict, main = "Strict Consensus")
trees2 = list(tree1, tree2)
# Map using minimum branch length per shared edge
mapped_min <- map_branch_lengths(strict, trees2, method = "minimum")
plot(mapped_min)
par(mfrow = c(1, 4))
plot(tree1, main = "Tree 1")
plot(tree2, main = "Tree 2")
plot(strict, main = "Strict Consensus")
plot(mapped_min)
set.seed(1)
tree1 <- rtree(n=8)
tree2 = tree1
tree2 <- rNNI(tree2, n = 1)  # perform one NNI (one rearrangement)
edges_to_change <- sample(1:length(tree2$edge.length), 2)
tree2$edge.length[edges_to_change] <- tree2$edge.length[edges_to_change] * runif(2, 0.5, 1.5)
trees2 = list(tree1, tree2)
# Compute the strict consensus tree
strict <- phangorn::consensus(list(tree1, tree2), p = 1.0)
tree2
# Compute the strict consensus tree
strict <- consensus(list(tree1, tree2), p = 1.0)
par(mfrow = c(1, 3))
plot(tree1, main = "Tree 1")
plot(tree2, main = "Tree 2")
plot(strict, main = "Strict Consensus")
tree1$edge.length
tree2$edge.length
sort(tree1$edge.length)
sort (tree2$edge.length)
mapped_min <- map_branch_lengths(strict, trees2, method = "minimum")
# Map using random tree
mapped_rand <- map_branch_lengths(tree1, trees2, method = "random")
par(mfrow = c(1, 4))
plot(tree1, main = "Tree 1")
plot(tree2, main = "Tree 2")
plot(strict, main = "Strict Consensus")
plot(mapped_min)
# Set up 1x4 plotting
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(tree1$edge.length, frame = "none", cex = 0.8)
ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.8)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), frame = "none", cex = 0.8)
ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.8)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::edgelabels(round(strict$edge.length, 2), frame = "none", cex = 0.8)
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(tree1$edge.length, frame = "none", cex = 0.8)
ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.8)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), frame = "none", cex = 0.8)
ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.8)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.8)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), frame = "none", cex = 0.8)
ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.8)
# Set up 1x4 plotting
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(tree1$edge.length, cex = 0.8)
ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.5)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), cex = 0.8)
ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.5)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.5)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), cex = 0.8)
ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.5)
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(round(tree1$edge.length), frame = "none", cex = 0.8)
ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.5)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), frame = "none", cex = 0.8)
ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.5)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.5)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), frame = "none", cex = 0.8)
ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.5)
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(round(tree1$edge.length), frame = "none", cex = 0.8)
ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.5)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), frame = "none", cex = 0.8)
ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.5)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.5)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), frame = "none", cex = 0.8)
ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.5)
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(round(tree1$edge.length), frame = "none", cex = 0.8)
ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.5)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), frame = "none", cex = 0.8)
ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.5)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.5)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), frame = "none", cex = 0.8)
ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.5)
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(round(tree1$edge.length), cex = 0.5)
ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.5)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), cex = 0.5)
ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.5)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.5)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), cex = 0.5)
ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.5)
frame = "none",
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(round(tree1$edge.length), cex = 0.5)
ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.5)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), cex = 0.5)
ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.5)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.5)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), cex = 0.5)
ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.5)
# Set up 1x4 plotting
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(round(tree1$edge.length), cex = 0.5)
#ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.5)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.5)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.5)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.5)
png("../tutorial/trees_plot.png", width = 2400, height = 800, res = 150)  # high-resolution
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(round(tree1$edge.length), cex = 0.5)
#ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.5)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.5)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.5)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.5)
dev.off()  # close the PNG device
tree1$edge.length
png("../tutorial/trees_plot.png", width = 2400, height = 800, res = 150)  # high-resolution
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(round(tree1$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.5)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.5)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.5)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.5)
dev.off()  # close the PNG device
set.seed(1)
# Simulate tree1
tree1 <- rtree(n=8)
# Simulate tree2 (similar to tree1, with one rearrangement and different branch lengths)
tree2 = tree1
tree2 <- rNNI(tree2, n = 1)  # perform one NNI (one rearrangement)
edges_to_change <- sample(1:length(tree2$edge.length), 6)
tree2$edge.length[edges_to_change] <- tree2$edge.length[edges_to_change] * runif(6, 0.5, 1.5)
trees2 = list(tree1, tree2)
# Compute the strict consensus tree
strict <- consensus(list(tree1, tree2), p = 1.0)
# Plot to visualize
par(mfrow = c(1, 3))
plot(tree1, main = "Tree 1")
plot(tree2, main = "Tree 2")
plot(strict, main = "Strict Consensus")
# Map using minimum branch length per shared edge
mapped_min <- map_branch_lengths(strict, trees2, method = "minimum")
# Map using random tree
mapped_rand <- map_branch_lengths(tree1, trees2, method = "random")
# Set up 1x4 plotting
png("../tutorial/trees_plot.png", width = 2400, height = 800, res = 150)  # high-resolution
par(mfrow = c(1, 4), mar = c(4, 4, 2, 2))
# Plot Tree 1
plot(tree1, main = "Tree 1")
ape::edgelabels(round(tree1$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:tree1$Nnode + length(tree1$tip.label), frame = "circle", cex = 0.5)
# Plot Tree 2
plot(tree2, main = "Tree 2")
ape::edgelabels(round(tree2$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:tree2$Nnode + length(tree2$tip.label), frame = "circle", cex = 0.5)
# Plot Strict Consensus
plot(strict, main = "Strict Consensus")
ape::nodelabels(1:strict$Nnode + length(strict$tip.label), frame = "circle", cex = 0.5)
# Plot Mapped Minimum
plot(mapped_min, main = "Mapped Minimum")
ape::edgelabels(round(mapped_min$edge.length, 2), cex = 0.5)
#ape::nodelabels(1:mapped_min$Nnode + length(mapped_min$tip.label), frame = "circle", cex = 0.5)
dev.off()  # close the PNG device
# Map using minimum branch length per shared edge
mapped_min <- map_branch_lengths(MOL, TE, method = "minimum")
strict = read.tree("../testdata/004a_strictConsensus_MOL_TNT_results.nwk")
mpts = read.tree("../testdata/004a_trees_MOL_TNT_results.nwk")
mpts = read.tree("../testdata/004a_MOL_TNT_results.out")
mpts = ReadTntTree("../testdata/004a_MOL_TNT_results.out")
strict = read.tree("../testdata/004a_strictConsensus_MOL_TNT_results.nwk")
mpts = ReadTntTree("../testdata/004a_MOL_TNT_results.out")
mpts
mpts[[1]]
class(mpts)
mpts[[1]]
strict = read.tree("../testdata/cymb_IP_GB.1.nwk")
mpts = ReadTntTree("../testdata/cymb_IP_trees.nwk")
mpts = read.tree("../testdata/cymb_IP_trees.nwk")
mpts[[1]]
# Map using minimum branch length per shared edge
mapped_min <- map_branch_lengths(strict, mpts, method = "minimum")
# Plot
plot(mapped_min, main = "Tree 1")
# Plot
plot(ladderize(mapped_min), main = "Tree 1")
# Plot
png("../tutorial/cymb_plot.png", width = 2400, height = 800, res = 150)  # high-resolution
strict = read.tree("../testdata/cymb_IP_GB.1.nwk")
mpts = read.tree("../testdata/cymb_IP_trees.nwk")
# Map using minimum branch length per shared edge
mapped_min <- map_branch_lengths(strict, mpts, method = "minimum")
# Plot
png("../tutorial/cymb_plot.png", width = 2400, height = 800, res = 150)  # high-resolution
plot(ladderize(mapped_min), main = "Tree 1")
dev.off()  # close the PNG device
library(readxl)
if (!require((readxl)) install.packages("readxl", dependencies = TRUE)
if (!require(readxl)) install.packages("readxl", dependencies = TRUE)
# Set the working directory
knitr::opts_knit$set(root.dir = "/Users/labanfibios/Desktop/Doutorado/Project/B3_PrepDyn/GitHub/test_data/simulations_v1_R/")
if (!require(ggplot2)) install.packages("ggplot2", dependencies = TRUE)
if (!require(GGally)) install.packages("GGally", dependencies = TRUE)
if (!require(viridis)) install.packages("viridis")
if (!require(readxl)) install.packages("readxl", dependencies = TRUE)
# Set the working directory
setwd("/Users/labanfibios/Desktop/Doutorado/Project/B3_PrepDyn/GitHub/test_data/simulations_v1_R/")
# Read the data
df <- read_excel("simulations_complexity.xlsx", sheet = "new")
# Inspect the data structure
str(df)
# Run model
model <- lm(log(prepDyn_CPU_time) ~ log(n_leaves) + log(n_columns) + log(n_partitions), data = df)
summary(model)
# Plot: Time vs Partitions, grouped by (n_leaves, n_columns)
df$group <- interaction(df$n_leaves, df$n_columns, drop = TRUE)
p <- ggplot(df, aes(x = n_partitions, y = prepDyn_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. partitions",
y = "CPU time (s)",
color = "No. leaves × No. characters") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
ggsave("simulations_complexityPartitions_prepDyn.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
df$group <- interaction(df$n_columns, df$n_partitions, drop = TRUE)
p <- ggplot(df, aes(x = n_leaves, y = prepDyn_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. leaves",
y = "CPU time (s)",
color = "No. characters × No. partitions") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
ggsave("simulations_complexityLeaves_prepDyn.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
df$group <- interaction(df$n_leaves, df$n_partitions, drop = TRUE)
p <- ggplot(df, aes(x = n_columns, y = prepDyn_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. characters",
y = "CPU time (s)",
color = "No. leaves × No. partitions") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
ggsave("simulations_complexityCharacters_prepDyn.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
?sink
# Run model
model <- lm(log(swap_CPU_time) ~ log(n_leaves) + log(n_columns) + log(n_partitions), data = df)
summary(model)
# Run model
model <- lm(log(cost) ~ log(n_leaves) + log(n_columns) + log(n_partitions), data = df)
summary(model)
# Run model
model <- lm(log(swap_CPU_time) ~ log(n_leaves) + log(n_columns) + log(n_partitions), data = df)
summary(model)
# Run model
model <- lm(log(swap_CPU_time) ~ log(n_leaves) * log(n_columns) * log(n_partitions), data = df)
summary(model)
# Run model
model <- lm(log(cost) ~ log(n_leaves) * log(n_columns) * log(n_partitions), data = df)
summary(model)
# Run model
model <- lm(log(swap_CPU_time) ~ log(n_leaves) + log(n_columns) + log(n_partitions) + log(n_partitions):log(n_leaves), data = df)
summary(model)
# Run model
model <- lm(log(swap_CPU_time) ~ log(n_leaves) + log(n_columns) + log(n_partitions) + log(n_partitions):log(n_leaves):log(n_columns), data = df)
summary(model)
# Run model
model <- lm(log(swap_CPU_time) ~ log(n_leaves) + log(n_columns) + log(n_partitions), data = df)
summary(model)
df$group <- interaction(df$n_leaves, df$n_columns, drop = TRUE)
p <- ggplot(df, aes(x = n_partitions, y = cost, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. partitions",
y = "Parsimony score",
color = "No. leaves × No. characters") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
ggsave("simulations_empiricalCostPartitions_prepDyn.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
df$group <- interaction(df$n_leaves, df$n_columns, drop = TRUE)
p <- ggplot(df, aes(x = n_partitions, y = log(cost), color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. partitions",
y = "Parsimony score",
color = "No. leaves × No. characters") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
ggsave("simulations_empiricalCostPartitions_prepDyn.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
df$group <- interaction(df$n_leaves, df$n_columns, drop = TRUE)
p <- ggplot(df, aes(x = n_partitions, y = swap_CPU_time, color = group)) +
geom_line() +
geom_point() +
labs(title = "",
x = "No. partitions",
y = "CPU time (s) for phylogenetic analyses",
color = "No. leaves × No. characters") +
theme_classic() +
scale_color_viridis_d(option = "D")  # discrete viridis palette
ggsave("simulations_empiricalTimePartitions_prepDyn.jpg", p, width = 8, height = 5, dpi = 300, units = "in")
